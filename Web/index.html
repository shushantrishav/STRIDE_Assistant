<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Roleplay Chat</title>
    <!-- Use Tailwind CSS for a modern, responsive design -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light Facebook/Telegram background */
            color: #1f2937;
        }

        /* 1. Telegram-style chat background (subtle texture) */
        #chat-history {
            background-color: #e5ddd5; /* Subtle warmer background */
            background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23000000' fill-opacity='0.08' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zM6 5v1H5z'/%3E%3C/g%3E%3C/svg%3E");
        }

        /* 2. Custom scrollbar for chat history */
        #chat-history::-webkit-scrollbar { width: 6px; }
        #chat-history::-webkit-scrollbar-thumb { background-color: #888; border-radius: 3px; }
        #chat-history::-webkit-scrollbar-track { background-color: transparent; }

        /* 3. Message bubble base styling for consistent margins */
        .chat-message-wrapper {
            margin-bottom: 8px;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-0 sm:p-4">

    <!-- Main Container -->
    <div class="bg-white shadow-2xl overflow-hidden w-full max-w-lg flex flex-col h-screen sm:h-[90vh] sm:rounded-xl">
        
        <!-- Header (Mimics Telegram's top bar) -->
        <div class="bg-white text-gray-800 p-3 sm:p-4 border-b border-gray-200 flex items-center shadow-md">
            <div>
                <h1 class="text-lg font-semibold tracking-tight">AI Director</h1>
                <p class="text-xs text-gray-500">online</p>
            </div>
        </div>
        
        <!-- Chat History -->
        <div id="chat-history" class="flex-grow p-4 overflow-y-auto">
            <!-- Initial Message -->
            <div class="flex justify-center my-4">
                <span class="bg-gray-400 text-white text-xs font-medium px-3 py-1.5 rounded-full shadow-sm">
                    Today: Type your first message to begin.
                </span>
            </div>
            
            <!-- Loading Indicator Container (Hidden by default) -->
            <div id="loading-indicator-wrapper" class="hidden chat-message-wrapper justify-start">
                <div class="bg-white p-3 rounded-2xl rounded-tl-md max-w-xs shadow-sm border border-gray-100">
                    <div class="flex items-center space-x-2">
                        <svg class="animate-pulse h-2 w-2 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 8 8">
                            <circle cx="4" cy="4" r="4" />
                        </svg>
                        <span class="text-xs text-gray-500">typing...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Input Area (Fixed to bottom, full width) -->
        <div class="bg-white border-t border-gray-200 p-3 flex items-center space-x-3">
            <input type="text" id="user-input" placeholder="Message..."
                        class="flex-grow py-2 px-4 rounded-full border border-gray-300 focus:outline-none focus:ring-1 focus:ring-blue-500 transition-all duration-150 text-gray-700"
                        onkeydown="if(event.key === 'Enter' && !this.disabled) document.getElementById('send-btn').click()">
            
            <button id="send-btn"
                        class="bg-blue-500 text-white p-3 rounded-full shadow-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <!-- Send Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                    <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.599 60.599 0 0018.445-8.986.75.75 0 000-1.218A60.599 60.599 0 003.478 2.405z" />
                </svg>
            </button>
        </div>
    </div>

    <script>
        // --- Configuration ---
        // FIX: The URL was incorrectly wrapped in markdown link syntax ([...](...)).
        // We ensure it is a clean string literal.
        const API_ENDPOINT = 'http://127.0.0.1:8000/stream'; 
        
        // --- DOM Elements ---
        const chatHistory = document.getElementById('chat-history');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const loadingWrapper = document.getElementById('loading-indicator-wrapper');
        
        // --- State Variables ---
        let isWaitingForAI = false;
        let aiMessageContent = null; // Reference to the <p> element inside the bubble
        
        // State for managing narrative/JSON separation
        let inNarrativeMode = true; 
        let finalJsonPayload = ''; 
        let fullResponseText = ''; // Accumulates only narrative text

        // --- Utility Functions ---
        
        /**
         * Disables/enables input elements during streaming.
         * @param {boolean} state - true to disable, false to enable.
         */
        function toggleInput(state) {
            isWaitingForAI = state;
            userInput.disabled = state;
            sendBtn.disabled = state;
            loadingWrapper.classList.toggle('hidden', !state);
            if (!state) {
                userInput.focus();
                userInput.value = '';
            }
        }
        
        /**
         * Creates and appends a chat bubble to the history in Telegram style.
         * @param {string} content - The text content.
         * @param {string} role - 'user' or 'ai'.
         * @returns {HTMLElement} The content container element.
         */
        function createChatBubble(content, role) {
            const wrapper = document.createElement('div');
            wrapper.className = `flex ${role === 'user' ? 'justify-end' : 'justify-start'} chat-message-wrapper`;

            const bubble = document.createElement('div');
            bubble.className = `max-w-[85%] py-2 px-3 shadow-md text-sm whitespace-pre-wrap break-words transition-all duration-200 ${
                role === 'ai' 
                    ? 'bg-white text-gray-800 rounded-2xl rounded-tl-md shadow-sm border border-gray-100' 
                    : 'bg-blue-500 text-white rounded-2xl rounded-br-md'
            }`;

            const contentP = document.createElement('p');
            // If it's an AI message, start with the role tag and then the content
            if (role === 'ai') {
                const roleSpan = document.createElement('span');
                roleSpan.className = 'font-semibold text-blue-600 mr-2 text-xs';
                roleSpan.textContent = 'Director:';
                bubble.appendChild(roleSpan);
            }
            contentP.innerHTML = content.replace(/\n/g, '<br>'); 
            
            bubble.appendChild(contentP);
            wrapper.appendChild(bubble);
            chatHistory.appendChild(wrapper);
            chatHistory.scrollTop = chatHistory.scrollHeight; 
            
            return contentP; 
        }

        /**
         * Renders the final JSON payload discreetly below the main message.
         * @param {string} jsonString - The raw JSON string.
         */
        function displayJsonPayload(jsonString) {
            const metadataDiv = document.createElement('div');
            
            // Format the JSON nicely for display
            let prettyJson;
            try {
                // Ensure we only try to parse content that looks like JSON
                const cleanedJsonString = jsonString.trim();
                prettyJson = JSON.stringify(JSON.parse(cleanedJsonString), null, 2);
            } catch (e) {
                prettyJson = "Invalid JSON or Model Cleanup Required: " + jsonString.substring(0, 150) + "...";
            }

            metadataDiv.innerHTML = `<div class="text-xs text-gray-500 italic p-2 mt-2 bg-gray-100 rounded-md border border-gray-300 max-w-full overflow-x-auto">
                <span class="font-bold text-gray-600">-- Metadata --</span>
                <pre class="mt-1">${prettyJson}</pre>
            </div>`;
            
            const wrapper = document.createElement('div');
            wrapper.className = 'flex justify-start chat-message-wrapper w-full';
            wrapper.appendChild(metadataDiv);
            chatHistory.appendChild(wrapper);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // --- Main Function ---

        async function sendMessage(message) {
            if (isWaitingForAI || !message.trim()) return;

            const userMessage = message.trim();
            createChatBubble(userMessage, 'user');
            toggleInput(true); // Disable input and show 'typing...'

            // Reset state for new message
            aiMessageContent = createChatBubble('', 'ai');
            inNarrativeMode = true;
            finalJsonPayload = ''; 
            fullResponseText = '';

            try {
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_input: userMessage }) 
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Server-Sent Events (SSE) streaming logic
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let buffer = "";
                let isComplete = false;

                while (!isComplete) {
                    const { value, done } = await reader.read();
                    isComplete = done;

                    if (value) {
                        buffer += decoder.decode(value, { stream: !done });
                        
                        // Process the buffer line by line (SSE format split by \n\n)
                        const parts = buffer.split('\n\n');
                        buffer = parts.pop(); 

                        for (const part of parts) {
                            if (part.startsWith('data:')) {
                                const data = part.substring(5).trim();
                                if (data === '[DONE]') {
                                    isComplete = true;
                                    break;
                                }

                                try {
                                    const jsonChunk = JSON.parse(data);
                                    const token = jsonChunk.text || '';
                                    
                                    if (token) {
                                        // CRITICAL FIX: Live processing to separate narrative from JSON
                                        if (inNarrativeMode) {
                                            const jsonStartIndex = token.indexOf('{');
                                            
                                            if (jsonStartIndex === -1) {
                                                // Case A: Pure narrative token
                                                fullResponseText += token;
                                                
                                            } else {
                                                // Case B: JSON starts in this token
                                                inNarrativeMode = false;
                                                
                                                // Add final narrative part
                                                fullResponseText += token.substring(0, jsonStartIndex);
                                                
                                                // Start collecting JSON payload
                                                finalJsonPayload += token.substring(jsonStartIndex);
                                            }

                                            // Always update the narrative display while in narrative mode
                                            aiMessageContent.innerHTML = fullResponseText.replace(/\n/g, '<br>');

                                        } else {
                                            // Case C: Collecting JSON payload
                                            finalJsonPayload += token;
                                        }

                                        chatHistory.scrollTop = chatHistory.scrollHeight; 
                                    }
                                } catch (e) {
                                    console.warn('Skipping chunk (not valid JSON format):', data);
                                }
                            }
                        }
                    }
                }

                // After the stream ends, clean up and display the collected JSON payload
                if (finalJsonPayload) {
                    // Remove any trailing stop tokens (like ```)
                    const cleanedJson = finalJsonPayload.replace(/`+$/, '').trim();
                    if (cleanedJson) {
                         displayJsonPayload(cleanedJson);
                    }
                }

            } catch (error) {
                console.error("Chat Error:", error);
                // Display error message directly in the chat bubble
                if (aiMessageContent) {
                    // Make sure the last token is updated before showing the error
                    aiMessageContent.innerHTML = fullResponseText.replace(/\n/g, '<br>') + `<br><span class="text-red-500 font-bold">Connection Error: ${error.message}</span>`;
                } else {
                    createChatBubble(`Error: ${error.message}`, 'error', true);
                }
            } finally {
                toggleInput(false);
            }
        }
        
        // --- Event Listeners ---
        sendBtn.addEventListener('click', () => {
            sendMessage(userInput.value);
        });

        // Keydown listener already embedded in the input field for convenience
    </script>
</body>
</html>
